package org.kevoree.reputationAPI;

import org.kevoree.annotation.*;
import org.kevoree.framework.AbstractComponentType;
import org.kevoree.reputationmetamodel.*;
import org.kevoree.reputationmetamodel.impl.DefaultReputationmetamodelFactory;
import org.kevoree.trustAPI.TrustException;

import java.util.ArrayList;
import java.util.List;

/**
 * Created with IntelliJ IDEA.
 * User: franciscomoyanolara
 * Date: 25/10/13
 * Time: 16:36
 * To change this template use File | Settings | File Templates.
 */
@DictionaryType({
        @DictionaryAttribute(name = "trustContext", optional = false),
        @DictionaryAttribute(name = "group", optional = true)
})

@Provides({
        @ProvidedPort(name = "sendClaims", type = PortType.SERVICE, className = IClaimContainer.class)
})

@Requires({
        @RequiredPort(name = "sendClaims", type = PortType.SERVICE, className = IClaimContainer.class)
})
@Library(name = "Reputation")
@ComponentFragment
public class DistKevReputableEntity extends AbstractComponentType
                                implements IClaimSource, IReputationEngine, IClaimContainer {

    private ReputationmetamodelFactory repFactory = null;
    private ReputationRoot repRoot = null;
    private static int id = 0;

    @Start
    public void start() throws TrustException {
        System.out.println("initializing reputable distributed entity");
        repFactory = new DefaultReputationmetamodelFactory();
        repRoot = repFactory.createReputationRoot();
    }

    /******************** METHODS ASSOCIATED TO PORTS *******************/
    //A distributed reputable entity can provide the claims stored by itself
    //(and therefore, all the claims are generated by itself, because source is always getModelElement().getName())
    //The method retrieves the claims about a subject (name) for a target in a context
    @Port(name = "sendClaims", method = "sendClaims")
    public List<ClaimInfo> sendClaims(String context, String name, String target) {
        List<ClaimInfo> claims = new ArrayList<ClaimInfo>();
        for ( ReputationStatement rs : repRoot.getStatements() )
        {
            if ( rs.getContext().equals( getContext() ) &&
                    rs.getTarget().getIdTarget().equals( target ))
            {
                for( Claim claim : rs.getClaim() )
                {
                    if( claim.getName().equals( name ))
                    {
                        ClaimInfo ci = new ClaimInfo( claim.getName(), claim.getClaimValue().getValue() );
                        claims.add( ci );
                    }
                }
            }
        }
        return claims;
    }

    @Port(name = "sendClaims", method = "receiveClaims")
    public List<ClaimInfo> receiveClaims(String context, String name, String target) {
        return getPortByName( "sendClaims", IClaimContainer.class).sendClaims(context, name, target);
    }

    /*********** AUXILIARY METHODS **************/
    //A distributed reputable entity must store its own claims
    public final void makeClaim(String name, String value, String target) {

        String context = getContext();
        String source = getModelElement().getName();

        //We always want to create a new claim (with a new value)
        Claim c = repFactory.createClaim();
        ClaimValue cv = repFactory.createClaimValue();

        //We create the source if it does not exist yet
        Source s = repRoot.findSourcesByID(source);
        if( s == null )
        {
            s = repFactory.createSource();
            s.setIdSource(source);
            repRoot.addSources(s);
        }

        //We fill in the claim
        //The id of a claim is the name of the claim, the target, and the time stamp
        c.setIdClaim( name + target + "any date" );
        cv.setValue(value);
        cv.setTimeStamp("any date");
        c.setClaimValue( cv );
        repRoot.addClaims(c);

        //We create the target if it does not exist yet
        Target t = repRoot.findTargetsByID(target);
        if ( t == null )
        {
            t = repFactory.createTarget();
            t.setIdTarget(target);
            repRoot.addTargets(t);
        }

        //We create the reputation statement
        ReputationStatement rstatement = repFactory.createReputationStatement();
        rstatement.setIdRepStatement( String.valueOf( id ) );
        rstatement.setContext(context);
        rstatement.setSource(s);
        rstatement.setTarget(t);
        rstatement.addClaim(c);
        repRoot.addStatements(rstatement);

        ++id;
    }

    public final String getBelongingGroup()
    {
        return ( String ) getDictionary().get("group");
    }

    public final String getContext()
    {
        return ( String ) getDictionary().get("trustContext");
    }
    /******************************************************/

    //A distributed reputable entity is in charge itself to compute a reputation score
    public Object computeReputation(String context, String target){ return null; }

}
